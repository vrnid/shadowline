import React, { useState, useEffect, useRef, useCallback } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, onSnapshot, deleteDoc, collection, getDocs, addDoc, query } from 'firebase/firestore';

// Ensure Tailwind CSS is loaded (assuming it's available in the environment)
// No explicit import needed for Tailwind classes in React JSX if it's set up globally.

function App() {
  // Firebase and Auth states
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState('');
  const [isAuthReady, setIsAuthReady] = useState(false);

  // WebRTC states
  const [localStream, setLocalStream] = useState(null);
  const [peerConnection, setPeerConnection] = useState(null);
  const [roomId, setRoomId] = useState('');
  const [currentRoomId, setCurrentRoomId] = useState('');
  const [statusMessage, setStatusMessage] = useState('请输入房间ID并加入');

  // Text chat states
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const messagesEndRef = useRef(null); // Ref for auto-scrolling chat
  const [isSendingImage, setIsSendingImage] = useState(false); // State for image sending loading

  // Audio control states
  const [isLocalMicMuted, setIsLocalMicMuted] = useState(false); // State for local microphone mute
  const [isRemoteAudioMuted, setIsRemoteAudioMuted] = useState(false); // State for remote audio mute
  const [micActiveStatusText, setMicActiveStatusText] = useState('麦克风未激活'); // Visual status for local mic

  // Refs for audio elements
  const localAudioRef = useRef(null);
  const remoteAudioRef = useRef(null);

  // Firebase configuration and app ID (provided by the environment)
  const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
  const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

  // 1. Initialize Firebase and authenticate
  useEffect(() => {
    try {
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const authentication = getAuth(app);

      setDb(firestore);
      setAuth(authentication);

      // Listen for auth state changes
      const unsubscribe = onAuthStateChanged(authentication, async (user) => {
        if (user) {
          setUserId(user.uid);
          setIsAuthReady(true);
          console.log("Firebase认证成功，用户ID:", user.uid);
        } else {
          // If no user, sign in anonymously or with custom token
          try {
            if (initialAuthToken) {
              await signInWithCustomToken(authentication, initialAuthToken);
              console.log("使用自定义令牌登录");
            } else {
              await signInAnonymously(authentication);
              console.log("匿名登录");
            }
          } catch (error) {
            console.error("Firebase认证失败:", error);
            setStatusMessage("认证失败，请检查控制台");
          }
        }
      });

      return () => unsubscribe(); // Cleanup auth listener on unmount
    } catch (error) {
      console.error("Firebase初始化失败:", error);
      setStatusMessage("Firebase初始化失败，请检查控制台");
    }
  }, []);

  // 2. Get local media stream (microphone)
  const startLocalStream = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      setLocalStream(stream);
      if (localAudioRef.current) {
        localAudioRef.current.srcObject = stream;
        localAudioRef.current.muted = true; // Always mute local playback to avoid echo
      }
      setStatusMessage('已获取麦克风权限');
      setMicActiveStatusText('麦克风活跃'); // Set to active when stream starts
      console.log('已获取本地媒体流:', stream);
      return stream;
    } catch (error) {
      console.error('获取本地媒体流失败:', error);
      setStatusMessage('获取麦克风权限失败: ' + error.message);
      setMicActiveStatusText('麦克风获取失败'); // Set to failed
      return null;
    }
  };

  // 3. Create RTCPeerConnection
  const createPeerConnection = (stream) => {
    console.log('正在创建RTCPeerConnection...');
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }, // Google's public STUN server
      ],
    });

    // Add local stream tracks to the peer connection
    stream.getTracks().forEach(track => {
      pc.addTrack(track, stream);
      console.log('已添加本地音频轨道到PeerConnection');
    });

    // Handle ICE candidates
    pc.onicecandidate = async (event) => {
      if (event.candidate) {
        if (db && userId && currentRoomId) {
          // Send ICE candidate to Firestore
          await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/iceCandidates`, userId), {
            candidate: event.candidate.toJSON(),
            timestamp: Date.now(),
          }, { merge: true });
          console.log('发送ICE候选者:', event.candidate.candidate); // Log only the candidate string
        }
      } else {
        console.log('ICE收集完成');
      }
    };

    // Handle remote tracks
    pc.ontrack = (event) => {
      if (remoteAudioRef.current && event.streams && event.streams[0]) {
        remoteAudioRef.current.srcObject = event.streams[0];
        // Apply current remote mute state
        remoteAudioRef.current.muted = isRemoteAudioMuted;
        console.log('收到远程流:', event.streams[0]);
        setStatusMessage('已连接到语音聊天');
      }
    };

    // Log connection state changes
    pc.onconnectionstatechange = (event) => {
      console.log('WebRTC连接状态改变:', pc.connectionState);
      setStatusMessage(`WebRTC连接状态: ${pc.connectionState}`);
    };

    // Log signaling state changes
    pc.onsignalingstatechange = (event) => {
      console.log('WebRTC信令状态改变:', pc.signalingState);
    };

    setPeerConnection(pc);
    return pc;
  };

  // 4. Join Room
  const joinRoom = async () => {
    if (!db || !userId || !roomId) {
      setStatusMessage('请先输入房间ID并确保已认证');
      return;
    }
    if (peerConnection) {
      setStatusMessage('您已在房间中，请先离开');
      return;
    }

    setStatusMessage('正在加入房间...');
    setCurrentRoomId(roomId); // Set the current active room ID
    setMessages([]); // Clear previous messages when joining a new room
    setIsLocalMicMuted(false); // Reset mic mute state on joining
    setIsRemoteAudioMuted(false); // Reset remote mute state on joining
    setMicActiveStatusText('麦克风未激活'); // Reset mic status text

    try {
      const stream = await startLocalStream();
      if (!stream) return;

      const pc = createPeerConnection(stream);

      // Create offer
      console.log('正在创建WebRTC报价...');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      console.log('已设置本地描述 (报价):', offer);

      // Save offer to Firestore
      await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/offers`, userId), {
        sdp: offer.sdp,
        type: offer.type,
        timestamp: Date.now(),
      });
      setStatusMessage('已发送报价，等待对方响应...');
      console.log('已发送WebRTC报价到Firestore');

      // Listen for answers and ICE candidates from other peers in the room
      listenForSignalingData(pc, roomId);

    } catch (error) {
      console.error('加入房间失败:', error);
      setStatusMessage('加入房间失败: ' + error.message);
      // Clean up if join fails
      leaveRoom();
    }
  };

  // 5. Listen for signaling data (offers, answers, ICE candidates)
  const listenForSignalingData = (pc, currentRoom) => {
    if (!db || !userId || !currentRoom) return;

    console.log('正在监听Firestore信令数据...');

    // Listen for offers from other users
    const offersRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoom}/offers`);
    onSnapshot(offersRef, async (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === 'added' && change.doc.id !== userId) { // Ignore our own offer
          const data = change.doc.data();
          if (data.type === 'offer') {
            console.log('收到新报价 (来自Firestore):', data);
            setStatusMessage('收到新报价，正在创建应答...');
            await handleOffer(pc, data.sdp);
          }
        }
      });
    });

    // Listen for answers from other users
    const answersRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoom}/answers`);
    onSnapshot(answersRef, async (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === 'added' && change.doc.id !== userId) { // Ignore our own answer
          const data = change.doc.data();
          if (data.type === 'answer') {
            console.log('收到应答 (来自Firestore):', data);
            setStatusMessage('收到应答，正在建立连接...');
            await handleAnswer(pc, data.sdp);
          }
        }
      });
    });

    // Listen for ICE candidates from other users
    const iceCandidatesRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoom}/iceCandidates`);
    onSnapshot(iceCandidatesRef, async (snapshot) => {
      snapshot.docChanges().forEach(async (change) => {
        if (change.type === 'added' && change.doc.id !== userId) { // Ignore our own candidates
          const data = change.doc.data();
          if (data.candidate) {
            console.log('收到ICE候选者 (来自Firestore):', data.candidate);
            setStatusMessage('收到ICE候选者...');
            await handleIceCandidate(pc, data.candidate);
          }
        }
      });
    });
  };

  // 6. Handle incoming offer
  const handleOffer = async (pc, sdp) => {
    try {
      console.log('正在设置远程描述 (报价)...');
      await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
      console.log('正在创建WebRTC应答...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      console.log('已设置本地描述 (应答):', answer);

      // Send answer to Firestore
      await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/answers`, userId), {
        sdp: answer.sdp,
        type: answer.type,
        timestamp: Date.now(),
      });
      console.log('已发送WebRTC应答到Firestore');
      setStatusMessage('已发送应答');
    } catch (error) {
      console.error('处理报价失败:', error);
      setStatusMessage('处理报价失败: ' + error.message);
    }
  };

  // 7. Handle incoming answer
  const handleAnswer = async (pc, sdp) => {
    try {
      console.log('正在设置远程描述 (应答)...');
      await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp }));
      console.log('已设置远程应答');
      setStatusMessage('连接已建立');
    } catch (error) {
      console.error('处理应答失败:', error);
      setStatusMessage('处理应答失败: ' + error.message);
    }
  };

  // 8. Handle incoming ICE candidate
  const handleIceCandidate = async (pc, candidate) => {
    try {
      console.log('正在添加ICE候选者...');
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
      console.log('已添加ICE候选者');
    } catch (error) {
      console.error('添加ICE候选者失败:', error);
      setStatusMessage('添加ICE候选者失败: ' + error.message);
    }
  };

  // 9. Leave Room
  const leaveRoom = async () => {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      setLocalStream(null);
      console.log('已停止本地媒体流');
    }
    if (peerConnection) {
      peerConnection.close();
      setPeerConnection(null);
      console.log('已关闭PeerConnection');
    }

    // Clean up signaling data in Firestore for this user
    if (db && userId && currentRoomId) {
      try {
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`, userId));
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/answers`, userId));
        await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/iceCandidates`, userId));
        console.log('已清除Firestore信令数据');

        // Optional: If the room becomes empty, delete the room document itself
        const roomOffers = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`));
        const roomAnswers = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/answers`));
        const roomCandidates = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/iceCandidates`));

        if (roomOffers.empty && roomAnswers.empty && roomCandidates.empty) {
          // Check if there are any messages left before deleting the room document
          const roomMessages = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/messages`));
          if (roomMessages.empty) {
            await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms`, currentRoomId));
            console.log('房间已空，已删除房间文档');
          }
        }

      } catch (error) {
        console.error('清除Firestore数据失败:', error);
      }
    }

    setCurrentRoomId('');
    setStatusMessage('已离开房间');
    setMessages([]); // Clear messages on leaving
    setIsLocalMicMuted(false); // Reset mic mute state
    setIsRemoteAudioMuted(false); // Reset remote mute state
    setMicActiveStatusText('麦克风未激活'); // Reset mic status text
    console.log('已离开房间');
  };

  // 10. Send text or image message
  const sendMessage = async (messageText = '', imageData = '') => {
    if (!db || !userId || !currentRoomId || (messageText.trim() === '' && imageData === '')) {
      setStatusMessage('无法发送消息：请加入房间并输入内容或拖入图片');
      return;
    }

    setIsSendingImage(true); // Set loading state for image sending
    try {
      await addDoc(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/messages`), {
        senderId: userId,
        text: messageText,
        imageData: imageData, // Store Base64 image data
        timestamp: Date.now(),
      });
      setNewMessage(''); // Clear input field
      setStatusMessage('消息已发送');
      console.log('消息已发送到Firestore');
    } catch (error) {
      console.error('发送消息失败:', error);
      setStatusMessage('发送消息失败: ' + error.message);
    } finally {
      setIsSendingImage(false); // Clear loading state
    }
  };

  // 11. Listen for text messages
  useEffect(() => {
    if (!db || !currentRoomId) return;

    console.log('正在监听文本消息...');
    const messagesRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/messages`);
    // Fetch all messages and sort in memory as orderBy can cause issues
    const q = query(messagesRef); // Removed orderBy

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const newMessages = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      // Sort messages by timestamp in memory
      newMessages.sort((a, b) => a.timestamp - b.timestamp);
      setMessages(newMessages);
      // Scroll to the latest message
      if (messagesEndRef.current) {
        messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      }
    }, (error) => {
      console.error("监听消息失败:", error);
      setStatusMessage("监听消息失败: " + error.message);
    });

    return () => unsubscribe(); // Cleanup listener on unmount or room change
  }, [db, currentRoomId, appId]); // Re-run effect when db or currentRoomId changes

  // Handle drag over event for image drop
  const handleDragOver = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = 'copy'; // Visual feedback for copy
  }, []);

  // Handle drop event for image
  const handleDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();

    if (!currentRoomId) {
      setStatusMessage('请先加入房间才能发送图片');
      return;
    }

    setIsSendingImage(true); // Start loading indicator

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      const file = files[0];
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (event) => {
          sendMessage('', event.target.result); // Send image data
        };
        reader.onerror = (error) => {
          console.error('读取图片失败:', error);
          setStatusMessage('读取图片失败: ' + error.message);
          setIsSendingImage(false);
        };
        reader.readAsDataURL(file); // Read file as Base64
      } else {
        setStatusMessage('只能拖入图片文件');
        setIsSendingImage(false);
      }
    } else {
      setIsSendingImage(false);
    }
  }, [currentRoomId, sendMessage]); // Depend on currentRoomId and sendMessage

  // Toggle local microphone mute
  const toggleLocalMic = () => {
    if (localStream) {
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !track.enabled;
      });
      setIsLocalMicMuted(!isLocalMicMuted);
      const newStatus = !isLocalMicMuted ? '麦克风已静音' : '麦克风已开启';
      setStatusMessage(newStatus);
      setMicActiveStatusText(!isLocalMicMuted ? '麦克风静音' : '麦克风活跃'); // Update visual status
      console.log('麦克风状态:', newStatus);
    } else {
      setStatusMessage('请先加入房间以控制麦克风');
    }
  };

  // Toggle remote audio mute
  const toggleRemoteAudio = () => {
    if (remoteAudioRef.current) {
      remoteAudioRef.current.muted = !remoteAudioRef.current.muted;
      setIsRemoteAudioMuted(!isRemoteAudioMuted);
      setStatusMessage(isRemoteAudioMuted ? '对方已取消静音' : '对方已静音');
      console.log('远程音频状态:', isRemoteAudioMuted ? '已取消静音' : '已静音');
    } else {
      setStatusMessage('没有远程音频流可静音');
    }
  };


  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-500 to-indigo-600 flex items-center justify-center p-4 font-sans">
      <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md text-center transform transition-all duration-300 hover:scale-105">
        <h1 className="text-3xl font-extrabold text-gray-800 mb-6">远程语音和文本聊天</h1>

        <div className="mb-6">
          <label htmlFor="roomId" className="block text-gray-700 text-sm font-bold mb-2">
            房间ID:
          </label>
          <input
            type="text"
            id="roomId"
            value={roomId}
            onChange={(e) => setRoomId(e.target.value)}
            placeholder="输入房间ID (例如: my-chat-room-123)"
            className="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200"
          />
        </div>

        <div className="flex flex-col space-y-4 mb-6">
          <button
            onClick={joinRoom}
            disabled={!isAuthReady || !roomId || currentRoomId === roomId}
            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            加入房间
          </button>
          <button
            onClick={leaveRoom}
            disabled={!currentRoomId}
            className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            离开房间
          </button>
        </div>

        {currentRoomId && (
          <div className="flex justify-center space-x-4 mb-6">
            <button
              onClick={toggleLocalMic}
              disabled={!localStream}
              className={`py-2 px-4 rounded-lg font-bold transition-all duration-300 ${isLocalMicMuted ? 'bg-gray-500 hover:bg-gray-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'} disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              {isLocalMicMuted ? '麦克风已静音' : '麦克风开'}
            </button>
            <button
              onClick={toggleRemoteAudio}
              disabled={!remoteAudioRef.current || !remoteAudioRef.current.srcObject}
              className={`py-2 px-4 rounded-lg font-bold transition-all duration-300 ${isRemoteAudioMuted ? 'bg-gray-500 hover:bg-gray-600 text-white' : 'bg-purple-500 hover:bg-purple-600 text-white'} disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              {isRemoteAudioMuted ? '对方已静音' : '静音对方'}
            </button>
          </div>
        )}

        {currentRoomId && (localStream || micActiveStatusText.includes('失败')) && ( // Show status if stream exists or failed to get
          <p className="text-sm text-gray-600 mt-2 mb-4"> {/* Added margin-bottom for spacing */}
            麦克风状态: <span className={`font-semibold ${micActiveStatusText.includes('静音') || micActiveStatusText.includes('失败') ? 'text-red-500' : 'text-green-500'}`}>
              {micActiveStatusText}
            </span>
          </p>
        )}

        <div className="bg-gray-100 p-4 rounded-lg mb-6 text-left">
          <p className="text-sm text-gray-600 mb-2">
            <strong>状态:</strong> <span className="font-semibold text-gray-800">{statusMessage}</span>
          </p>
          <p className="text-sm text-gray-600">
            <strong>您的用户ID:</strong> <span className="font-mono text-xs break-all text-gray-700">{userId || 'N/A'}</span>
          </p>
          {currentRoomId && (
            <p className="text-sm text-gray-600">
              <strong>当前房间ID:</strong> <span className="font-mono text-xs break-all text-gray-700">{currentRoomId}</span>
            </p>
          )}
        </div>

        {/* Text Chat Section */}
        {currentRoomId && (
          <div className="bg-white p-4 rounded-lg shadow-inner border border-gray-200 mb-6">
            <h2 className="text-xl font-bold text-gray-700 mb-4">文本聊天</h2>
            <div
              className="h-64 overflow-y-auto border border-gray-300 rounded-lg p-3 mb-4 bg-gray-50 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200"
              onDragOver={handleDragOver}
              onDrop={handleDrop}
            >
              {messages.length === 0 ? (
                <p className="text-gray-500 text-center italic">还没有消息... (拖放图片到这里发送)</p>
              ) : (
                messages.map((msg) => (
                  <div key={msg.id} className={`mb-2 ${msg.senderId === userId ? 'text-right' : 'text-left'}`}>
                    <span className={`inline-block p-2 rounded-lg max-w-[80%] ${msg.senderId === userId ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`}>
                      <strong className="text-xs">{msg.senderId === userId ? '您' : `用户 ${msg.senderId.substring(0, 6)}...`}:</strong>
                      {msg.imageData ? (
                        <img
                          src={msg.imageData}
                          alt="聊天图片"
                          className="max-w-full h-auto rounded-md mt-1"
                          onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/150x100/FF0000/FFFFFF?text=图片加载失败'; }}
                        />
                      ) : (
                        <p>{msg.text}</p>
                      )}
                      <span className="block text-xs text-opacity-75 mt-1">
                        {new Date(msg.timestamp).toLocaleTimeString()}
                      </span>
                    </span>
                  </div>
                ))
              )}
              {isSendingImage && (
                <div className="text-center text-gray-500 italic">
                  正在发送图片...
                </div>
              )}
              <div ref={messagesEndRef} /> {/* Scroll target */}
            </div>
            <div className="flex">
              <input
                type="text"
                value={newMessage}
                onChange={(e) => setNewMessage(e.target.value)}
                onKeyPress={(e) => {
                  if (e.key === 'Enter') {
                    sendMessage(newMessage);
                  }
                }}
                placeholder="输入您的消息..."
                className="flex-grow shadow appearance-none border rounded-l-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200"
                disabled={!currentRoomId || isSendingImage}
              />
              <button
                onClick={() => sendMessage(newMessage)}
                className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-r-lg shadow-md transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled={!currentRoomId || newMessage.trim() === '' || isSendingImage}
              >
                发送
              </button>
            </div>
          </div>
        )}

        {/* Audio elements for local and remote streams */}
        <div className="hidden"> {/* Hide these as they are just for audio */}
          <audio ref={localAudioRef} autoPlay muted></audio> {/* Muted for local playback */}
          <audio ref={remoteAudioRef} autoPlay></audio>
        </div>

        <p className="text-xs text-gray-500 mt-4">
          请确保您的浏览器允许麦克风访问。
        </p>
      </div>
    </div>
  );
}

export default App;
