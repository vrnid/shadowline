<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHADOW LINE - 语音和文本聊天</title>
    <!-- 引入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* 设置全局字体为 Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 自定义滚动条样式 */
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* 隐藏元素 */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-500 to-indigo-600 flex items-center justify-center p-4 font-sans">
    <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md text-center transform transition-all duration-300 hover:scale-105">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6">SHADOW LINE</h1>

        <div class="mb-6">
            <label for="roomIdInput" class="block text-gray-700 text-sm font-bold mb-2">
                房间ID:
            </label>
            <input
                type="text"
                id="roomIdInput"
                placeholder="输入房间ID (例如: my-chat-room-123)"
                class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200"
            />
        </div>

        <div class="flex flex-col space-y-4 mb-6">
            <button
                id="joinRoomBtn"
                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
            >
                加入房间
            </button>
            <button
                id="leaveRoomBtn"
                class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled
            >
                离开房间
            </button>
        </div>

        <div id="audioControls" class="flex justify-center space-x-4 mb-6 hidden">
            <button
                id="toggleLocalMicBtn"
                class="py-2 px-4 rounded-lg font-bold transition-all duration-300 bg-green-500 hover:bg-green-600 text-white disabled:opacity-50 disabled:cursor-not-allowed"
            >
                麦克风开
            </button>
            <button
                id="toggleRemoteAudioBtn"
                class="py-2 px-4 rounded-lg font-bold transition-all duration-300 bg-purple-500 hover:bg-purple-600 text-white disabled:opacity-50 disabled:cursor-not-allowed"
            >
                静音对方
            </button>
        </div>

        <div class="bg-gray-100 p-4 rounded-lg mb-6 text-left">
            <p class="text-sm text-gray-600 mb-2">
                <strong>状态:</strong> <span id="statusMessage" class="font-semibold text-gray-800">请输入房间ID并加入</span>
            </p>
            <p class="text-sm text-gray-600">
                <strong>您的用户ID:</strong> <span id="userIdDisplay" class="font-mono text-xs break-all text-gray-700">N/A</span>
                <button
                    id="copyUserIdBtn"
                    class="ml-2 px-2 py-1 bg-gray-300 text-gray-800 text-xs rounded-md hover:bg-gray-400 transition-colors duration-200 hidden"
                    title="复制用户ID"
                >
                    复制
                </button>
            </p>
            <p id="currentRoomIdDisplay" class="text-sm text-gray-600 hidden">
                <strong>当前房间ID:</strong> <span id="currentRoomIdValue" class="font-mono text-xs break-all text-gray-700"></span>
            </p>
            <p id="roomUserCountDisplay" class="text-sm text-gray-600 hidden">
                <strong>当前房间人数:</strong> <span id="roomUserCountValue" class="font-semibold text-gray-800">0</span>
            </p>
            <p id="voiceConnectedStatus" class="text-sm text-green-600 font-bold mt-2 hidden">
                语音聊天已连接！
            </p>
        </div>

        <!-- Text Chat Section -->
        <div id="textChatSection" class="bg-white p-4 rounded-lg shadow-inner border border-gray-200 mb-6 hidden">
            <h2 class="text-xl font-bold text-gray-700 mb-4">文本聊天</h2>
            <div
                id="messagesContainer"
                class="h-64 overflow-y-auto border border-gray-300 rounded-lg p-3 mb-4 bg-gray-50 scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200"
            >
                <p class="text-gray-500 text-center italic">还没有消息... (拖放图片到这里发送)</p>
            </div>
            <div class="flex">
                <input
                    type="text"
                    id="newMessageInput"
                    placeholder="输入您的消息..."
                    class="flex-grow shadow appearance-none border rounded-l-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200"
                />
                <button
                    id="sendMessageBtn"
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-r-lg shadow-md transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    发送
                </button>
            </div>
        </div>

        <!-- Audio elements for local and remote streams -->
        <div class="hidden">
            <audio id="localAudio" autoplay muted></audio>
        </div>
        <!-- Container for multiple remote audio elements -->
        <div id="remoteAudiosContainer" class="flex flex-wrap justify-center gap-4 mt-4 hidden"></div>

        <p class="text-xs text-gray-500 mt-4">
            请确保您的浏览器允许麦克风访问。
        </p>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="customModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <h3 id="modalTitle" class="text-xl font-bold text-gray-800 mb-4"></h3>
            <p id="modalMessage" class="text-gray-700 mb-6"></p>
            <button
                id="modalCloseBtn"
                class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300"
            >
                确定
            </button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // 导入 writeBatch 以便在离开房间时更有效地清理数据
        import { getFirestore, doc, setDoc, onSnapshot, deleteDoc, collection, getDocs, addDoc, query, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =====================================================================================
        // ！！！重要提示：请务必将以下 Firebase 配置替换为您自己的项目凭据！！！
        // 您可以在 Firebase 控制台的项目设置 (Project settings) 中找到这些值。
        // 请务必替换所有 'YOUR_ACTUAL_...' 占位符为您的实际凭据。
        // =====================================================================================
        const appId = '1:274766423411:web:ef1549f49be22bf53b9106'; // 替换为您的 Firebase 项目 ID (例如: 'my-chat-app-12345')
        const firebaseConfig = {
                        apiKey: "AIzaSyAXlYCZr6F1Nunieg7CDeYM0O_6iX1AZq0",
                authDomain: "wuzi-1ecf3.firebaseapp.com",
                projectId: "wuzi-1ecf3",
                storageBucket: "wuzi-1ecf3.firebasestorage.app",
                messagingSenderId: "274766423411",
                appId: "1:274766423411:web:ef1549f49be22bf53b9106",
                measurementId: "G-EFPFDMRSMZ"
        };
        const initialAuthToken = null; // 如果您不使用自定义认证令牌，请保持为 null
        // =====================================================================================
        // Firebase 配置结束
        // =====================================================================================


        // Global state variables
        let db;
        let auth;
        let userId = '';
        let isAuthReady = false;
        let localStream = null;
        let peerConnections = new Map(); // 存储与每个远程用户对应的 RTCPeerConnection 实例
        let currentRoomId = '';
        let isLocalMicMuted = false;
        let isRemoteAudioMuted = false;
        let isSendingImage = false;
        let isConnectedToVoice = false; // New state for voice connection status
        let roomUserCount = 0; // New state for room user count

        // DOM Elements
        const roomIdInput = document.getElementById('roomIdInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const leaveRoomBtn = document.getElementById('leaveRoomBtn');
        const statusMessageSpan = document.getElementById('statusMessage');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const copyUserIdBtn = document.getElementById('copyUserIdBtn');
        const currentRoomIdDisplay = document.getElementById('currentRoomIdDisplay');
        const currentRoomIdValueSpan = document.getElementById('currentRoomIdValue');
        const roomUserCountDisplay = document.getElementById('roomUserCountDisplay'); // New DOM element for user count
        const roomUserCountValueSpan = document.getElementById('roomUserCountValue'); // New DOM element for user count value
        const audioControlsDiv = document.getElementById('audioControls');
        const toggleLocalMicBtn = document.getElementById('toggleLocalMicBtn');
        const toggleRemoteAudioBtn = document.getElementById('toggleRemoteAudioBtn');
        const localAudioRef = document.getElementById('localAudio');
        const remoteAudiosContainer = document.getElementById('remoteAudiosContainer'); // New container for remote audios
        const textChatSection = document.getElementById('textChatSection');
        const messagesContainer = document.getElementById('messagesContainer');
        const newMessageInput = document.getElementById('newMessageInput');
        const sendMessageBtn = document.getElementById('sendMessageBtn');
        const voiceConnectedStatus = document.getElementById('voiceConnectedStatus');

        // Modal Elements
        const customModal = document.getElementById('customModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // Function to show custom modal
        function showCustomModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            customModal.classList.remove('hidden');
        }

        // Function to update UI elements
        function updateUI() {
            joinRoomBtn.disabled = !isAuthReady || !roomIdInput.value || currentRoomId === roomIdInput.value;
            leaveRoomBtn.disabled = !currentRoomId;

            if (currentRoomId) {
                audioControlsDiv.classList.remove('hidden');
                textChatSection.classList.remove('hidden');
                currentRoomIdDisplay.classList.remove('hidden');
                currentRoomIdValueSpan.textContent = currentRoomId;
                roomUserCountDisplay.classList.remove('hidden'); // Show user count display
                roomUserCountValueSpan.textContent = roomUserCount; // Update user count value
                newMessageInput.disabled = isSendingImage;
                sendMessageBtn.disabled = newMessageInput.value.trim() === '' || isSendingImage;
            } else {
                audioControlsDiv.classList.add('hidden');
                textChatSection.classList.add('hidden');
                currentRoomIdDisplay.classList.add('hidden');
                roomUserCountDisplay.classList.add('hidden'); // Hide user count display
            }

            toggleLocalMicBtn.disabled = !localStream;
            toggleLocalMicBtn.textContent = isLocalMicMuted ? '麦克风已静音' : '麦克风开';
            toggleLocalMicBtn.classList.toggle('bg-gray-500', isLocalMicMuted);
            toggleLocalMicBtn.classList.toggle('hover:bg-gray-600', isLocalMicMuted);
            toggleLocalMicBtn.classList.toggle('bg-green-500', !isLocalMicMuted);
            toggleLocalMicBtn.classList.toggle('hover:bg-green-600', !isLocalMicMuted);

            // Remote audio mute button should be enabled if there's at least one remote stream
            toggleRemoteAudioBtn.disabled = remoteAudiosContainer.children.length === 0;
            toggleRemoteAudioBtn.textContent = isRemoteAudioMuted ? '所有对方已静音' : '静音所有对方';
            toggleRemoteAudioBtn.classList.toggle('bg-gray-500', isRemoteAudioMuted);
            toggleRemoteAudioBtn.classList.toggle('hover:bg-gray-600', isRemoteAudioMuted);
            toggleRemoteAudioBtn.classList.toggle('bg-purple-500', !isRemoteAudioMuted);
            toggleRemoteAudioBtn.classList.toggle('hover:bg-purple-600', !isRemoteAudioMuted);


            userIdDisplay.textContent = userId || 'N/A';
            if (userId) {
                copyUserIdBtn.classList.remove('hidden');
            } else {
                copyUserIdBtn.classList.add('hidden');
            }

            // Overall voice connected status based on any active peer connections
            if (isConnectedToVoice && currentRoomId) {
                voiceConnectedStatus.classList.remove('hidden');
            } else {
                voiceConnectedStatus.classList.add('hidden');
            }
        }

        // 1. Initialize Firebase and authenticate
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                    } else {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Firebase authentication failed:", error);
                            statusMessageSpan.textContent = "认证失败，请检查控制台";
                            showCustomModal("认证失败", "Firebase 认证失败，请检查您的网络连接或浏览器控制台。");
                        }
                    }
                    updateUI(); // Update UI after auth state changes
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                statusMessageSpan.textContent = "Firebase初始化失败，请检查控制台";
                showCustomModal("初始化失败", "Firebase 初始化失败，请检查您的配置或网络连接。");
            }
        }

        // 2. Get local media stream (microphone)
        async function startLocalStream() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                localStream = stream;
                if (localAudioRef) {
                    localAudioRef.srcObject = stream;
                    localAudioRef.muted = true; // Always mute local playback to avoid echo
                }
                statusMessageSpan.textContent = '已获取麦克风权限';
                updateUI();
                return stream;
            } catch (error) {
                console.error('获取本地媒体流失败:', error);
                let errorMessage = '未知错误';
                if (error.name === 'NotAllowedError') {
                    errorMessage = '麦克风权限被拒绝。请允许浏览器访问您的麦克风。';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = '未找到麦克风设备。请确保您的麦克风已连接。';
                } else {
                    errorMessage = error.message;
                }
                statusMessageSpan.textContent = '获取麦克风权限失败: ' + errorMessage;
                showCustomModal("麦克风访问失败", `无法获取麦克风权限: ${errorMessage}`);
                return null;
            }
        }

        // 3. Create RTCPeerConnection for a specific remote user
        function createPeerConnection(remoteUserId, stream) {
            console.log(`为用户 ${remoteUserId} 创建新的 PeerConnection`);
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
            });

            // Add local stream tracks to the peer connection
            if (stream) {
                stream.getTracks().forEach(track => pc.addTrack(track, stream));
            }

            // Handle ICE candidates for this specific peer connection
            pc.onicecandidate = async (event) => {
                if (event.candidate && db && userId && currentRoomId) {
                    // Send ICE candidate to Firestore, specific to remoteUserId
                    // Path: /room/{roomId}/signals/{senderId}/candidates/{receiverId}/{candidateId}
                    await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/signals/${userId}/candidates`, remoteUserId), {
                        candidate: event.candidate.toJSON(),
                        timestamp: Date.now(),
                        // Use a unique ID for the candidate document if necessary, e.g., event.candidate.sdpMid + event.candidate.candidate.split(' ')[4]
                    });
                    console.log(`发送ICE候选者给 ${remoteUserId}:`, event.candidate);
                }
            };

            // Handle remote tracks for this specific peer connection
            pc.ontrack = (event) => {
                if (event.streams && event.streams[0]) {
                    let audioEl = document.getElementById(`remoteAudio-${remoteUserId}`);
                    if (!audioEl) {
                        audioEl = document.createElement('audio');
                        audioEl.id = `remoteAudio-${remoteUserId}`;
                        audioEl.autoplay = true;
                        audioEl.controls = false; // Hide controls
                        audioEl.muted = isRemoteAudioMuted; // Apply global mute state
                        // Append to a container for remote audios
                        if (remoteAudiosContainer) {
                            remoteAudiosContainer.classList.remove('hidden'); // Show container
                            remoteAudiosContainer.appendChild(audioEl);
                        }
                    }
                    audioEl.srcObject = event.streams[0];
                    console.log(`收到远程流来自 ${remoteUserId}`);
                    statusMessageSpan.textContent = `已连接到语音聊天 (${remoteUserId})`;
                    isConnectedToVoice = true; // At least one voice connection is active
                    updateUI();
                }
            };

            // Handle connection state changes for this specific peer connection
            pc.onconnectionstatechange = (event) => {
                console.log(`Peer connection with ${remoteUserId} state changed:`, pc.connectionState);
                switch (pc.connectionState) {
                    case 'new':
                    case 'checking':
                        statusMessageSpan.textContent = `正在与 ${remoteUserId} 建立连接...`;
                        break;
                    case 'connected':
                        statusMessageSpan.textContent = `与 ${remoteUserId} 语音连接成功`;
                        isConnectedToVoice = true;
                        break;
                    case 'disconnected':
                    case 'failed':
                    case 'closed':
                        statusMessageSpan.textContent = `与 ${remoteUserId} 语音连接断开或失败`;
                        // Clean up audio element and peer connection if connection fails or closes
                        const audioEl = document.getElementById(`remoteAudio-${remoteUserId}`);
                        if (audioEl) audioEl.remove();
                        peerConnections.delete(remoteUserId); // Remove from map
                        isConnectedToVoice = peerConnections.size > 0; // Update overall status
                        break;
                    default:
                        statusMessageSpan.textContent = `与 ${remoteUserId} 连接状态: ${pc.connectionState}`;
                }
                updateUI();
            };

            peerConnections.set(remoteUserId, pc); // Store the PC in the map
            return pc;
        }

        // 4. Join Room
        async function joinRoom() {
            const roomId = roomIdInput.value.trim();
            if (!db || !userId || !roomId) {
                statusMessageSpan.textContent = '请先输入房间ID并确保已认证';
                showCustomModal("加入失败", "请先输入房间ID并确保已通过 Firebase 认证。");
                return;
            }
            // If already in a room, prevent re-joining
            if (currentRoomId && currentRoomId === roomId) {
                statusMessageSpan.textContent = '您已在当前房间中。';
                showCustomModal("已在房间中", "您已在当前房间中，无需重复加入。");
                return;
            }
            // If in a different room, leave first
            if (currentRoomId && currentRoomId !== roomId) {
                await leaveRoom(); // Leave the old room before joining a new one
            }

            statusMessageSpan.textContent = '正在加入房间...';
            currentRoomId = roomId;
            messagesContainer.innerHTML = '<p class="text-gray-500 text-center italic">还没有消息... (拖放图片到这里发送)</p>'; // Clear previous messages
            isLocalMicMuted = false;
            isRemoteAudioMuted = false;
            isConnectedToVoice = false;
            roomUserCount = 0; // Reset user count on joining
            updateUI();

            try {
                // Step 1: Get local media stream
                const stream = await startLocalStream();
                if (!stream) {
                    statusMessageSpan.textContent = '无法加入房间：未获取到麦克风权限。';
                    return;
                }

                // Step 2: Announce our presence in the room
                // This document will also be used to count active users in listenForRoomUsers
                await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`, userId), {
                    timestamp: Date.now(),
                    // No SDP here initially, just a presence marker
                });
                console.log(`用户 ${userId} 已在房间 ${currentRoomId} 宣布存在。`);

                // Step 3: Fetch existing peers and initiate connections
                const offersRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`);
                const existingOffersSnapshot = await getDocs(offersRef);

                existingOffersSnapshot.forEach(async (docSnap) => {
                    const remotePeerId = docSnap.id;
                    if (remotePeerId !== userId) {
                        console.log(`检测到现有用户 ${remotePeerId}，尝试建立连接...`);
                        // Create a new PeerConnection for this specific remote peer
                        const pc = createPeerConnection(remotePeerId, stream);

                        // Create an offer for this new peer connection
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);

                        // Send this offer to Firestore, specifically for the remotePeerId
                        // Path: /room/{roomId}/signals/{senderId}/offers/{receiverId}
                        await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/signals/${userId}/offers`, remotePeerId), {
                            sdp: offer.sdp,
                            type: offer.type,
                            timestamp: Date.now(),
                        });
                        console.log(`发送 WebRTC 报价给 ${remotePeerId}`);
                    }
                });

                // Step 4: Start listening for all incoming signals (offers, answers, candidates)
                // This listener will handle signals from new peers joining, and responses from existing peers.
                listenForSignalingData(currentRoomId, stream); // Pass stream for new PCs
                listenForTextMessages(currentRoomId);
                listenForRoomUsers(currentRoomId);

                statusMessageSpan.textContent = '已加入房间，正在尝试建立语音连接...';
                updateUI();

            } catch (error) {
                console.error('加入房间失败:', error);
                statusMessageSpan.textContent = '加入房间失败: ' + error.message;
                showCustomModal("加入房间失败", `加入房间时发生错误: ${error.message}`);
                leaveRoom(); // Clean up if join fails
            }
        }

        // 5. Listen for signaling data (offers, answers, ICE candidates)
        let unsubscribeSignals = []; // To store all signal unsubscribe functions

        function listenForSignalingData(roomId, localStream) {
            // Clear previous listeners
            unsubscribeSignals.forEach(unsub => unsub());
            unsubscribeSignals = [];

            if (!db || !userId || !roomId) return;

            // Listener for incoming OFFERS directed to THIS user
            // Path: /room/{roomId}/signals/{remoteUserId}/offers/{localUserId}
            const offersToMeRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals`);
            const unsubOffers = onSnapshot(offersToMeRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const remoteUserId = change.doc.id; // This is the sender of the offer
                        // Listen to the subcollection of offers from this remoteUserId specifically to us
                        const offersSubcollectionRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/offers`);
                        const unsubOffersSub = onSnapshot(query(offersSubcollectionRef, doc(offersSubcollectionRef, userId)), async (offerSnapshot) => { // Query for doc with our userId
                            offerSnapshot.docChanges().forEach(async (offerChange) => {
                                if (offerChange.type === 'added' && offerChange.doc.id === userId) { // Offer specifically for us
                                    const data = offerChange.doc.data();
                                    if (data.type === 'offer') {
                                        console.log(`收到来自 ${remoteUserId} 的报价:`, data);
                                        statusMessageSpan.textContent = `收到来自 ${remoteUserId} 的报价，正在创建应答...`;

                                        let pc = peerConnections.get(remoteUserId);
                                        if (!pc) {
                                            pc = createPeerConnection(remoteUserId, localStream); // Create new PC if it doesn't exist
                                        }

                                        await handleOffer(pc, data.sdp, remoteUserId);
                                        // Once processed, delete the offer to prevent re-processing
                                        await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/offers`, userId));
                                    }
                                }
                            });
                        });
                        unsubscribeSignals.push(unsubOffersSub); // Store sub-listener
                    }
                });
            }, (error) => {
                console.error("监听传入报价失败:", error);
                statusMessageSpan.textContent = "监听传入报价失败: " + error.message;
            });
            unsubscribeSignals.push(unsubOffers);


            // Listener for incoming ANSWERS directed to THIS user
            // Path: /room/{roomId}/signals/{remoteUserId}/answers/{localUserId}
            const answersToMeRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals`);
            const unsubAnswers = onSnapshot(answersToMeRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const remoteUserId = change.doc.id; // This is the sender of the answer
                        // Listen to the subcollection of answers from this remoteUserId specifically to us
                        const answersSubcollectionRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/answers`);
                        const unsubAnswersSub = onSnapshot(query(answersSubcollectionRef, doc(answersSubcollectionRef, userId)), async (answerSnapshot) => { // Query for doc with our userId
                            answerSnapshot.docChanges().forEach(async (answerChange) => {
                                if (answerChange.type === 'added' && answerChange.doc.id === userId) { // Answer specifically for us
                                    const data = answerChange.doc.data();
                                    if (data.type === 'answer') {
                                        console.log(`收到来自 ${remoteUserId} 的应答:`, data);
                                        statusMessageSpan.textContent = `收到来自 ${remoteUserId} 的应答，正在建立连接...`;

                                        const pc = peerConnections.get(remoteUserId);
                                        if (pc) {
                                            await handleAnswer(pc, data.sdp, remoteUserId);
                                            // Once processed, delete the answer
                                            await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/answers`, userId));
                                        } else {
                                            console.warn(`未找到与 ${remoteUserId} 对应的 PeerConnection 来处理应答。`);
                                        }
                                    }
                                }
                            });
                        });
                        unsubscribeSignals.push(unsubAnswersSub); // Store sub-listener
                    }
                });
            }, (error) => {
                console.error("监听传入应答失败:", error);
                statusMessageSpan.textContent = "监听传入应答失败: " + error.message;
            });
            unsubscribeSignals.push(unsubAnswers);


            // Listener for incoming ICE candidates directed to THIS user
            // Path: /room/{roomId}/signals/{remoteUserId}/candidates/{localUserId}
            const candidatesToMeRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals`);
            const unsubCandidates = onSnapshot(candidatesToMeRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const remoteUserId = change.doc.id; // This is the sender of the candidate
                        // Listen to the subcollection of candidates from this remoteUserId specifically to us
                        const candidatesSubcollectionRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/candidates`);
                        const unsubCandidatesSub = onSnapshot(query(candidatesSubcollectionRef, doc(candidatesSubcollectionRef, userId)), async (candidateSnapshot) => { // Query for doc with our userId
                            candidateSnapshot.docChanges().forEach(async (candidateChange) => {
                                if (candidateChange.type === 'added' && candidateChange.doc.id === userId) { // Candidate specifically for us
                                    const data = candidateChange.doc.data();
                                    if (data.candidate) {
                                        console.log(`收到来自 ${remoteUserId} 的ICE候选者:`, data.candidate);
                                        statusMessageSpan.textContent = `收到来自 ${remoteUserId} 的ICE候选者...`;

                                        const pc = peerConnections.get(remoteUserId);
                                        if (pc) {
                                            await handleIceCandidate(pc, data.candidate, remoteUserId);
                                            // Once processed, delete the candidate
                                            await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/signals/${remoteUserId}/candidates`, userId));
                                        } else {
                                            console.warn(`未找到与 ${remoteUserId} 对应的 PeerConnection 来处理ICE候选者。`);
                                        }
                                    }
                                }
                            });
                        });
                        unsubscribeSignals.push(unsubCandidatesSub); // Store sub-listener
                    }
                });
            }, (error) => {
                console.error("监听传入ICE候选者失败:", error);
                statusMessageSpan.textContent = "监听传入ICE候选者失败: " + error.message;
            });
            unsubscribeSignals.push(unsubCandidates);
        }

        // 6. Handle incoming offer
        async function handleOffer(pc, sdp, remoteUserId) {
            try {
                // Ensure the PC is in a state where it can accept an offer
                // 'stable' means it's ready to receive an offer
                if (pc.signalingState !== 'stable') {
                    console.warn(`PC for ${remoteUserId} is not stable (${pc.signalingState}), cannot set remote offer. Ignoring.`);
                    return;
                }
                await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                // Send answer to Firestore, specific to remoteUserId
                await setDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/signals/${userId}/answers`, remoteUserId), {
                    sdp: answer.sdp,
                    type: answer.type,
                    timestamp: Date.now(),
                });
                console.log(`已发送WebRTC应答给 ${remoteUserId}`);
                statusMessageSpan.textContent = `已发送应答给 ${remoteUserId}`;
            } catch (error) {
                console.error(`处理来自 ${remoteUserId} 的报价失败:`, error);
                statusMessageSpan.textContent = `处理报价失败: ${error.message}`;
                showCustomModal("处理报价失败", `处理来自 ${remoteUserId} 的 WebRTC 报价时发生错误: ${error.message}`);
            }
        }

        // 7. Handle incoming answer
        async function handleAnswer(pc, sdp, remoteUserId) {
            try {
                // Ensure the PC is in a state where it can accept an answer (i.e., we sent an offer)
                // 'have-local-offer' means we sent an offer and are waiting for an answer
                if (pc.signalingState !== 'have-local-offer') {
                    console.warn(`PC for ${remoteUserId} is not in have-local-offer state (${pc.signalingState}), cannot set remote answer. Ignoring.`);
                    return;
                }
                await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp }));
                console.log(`已设置远程应答来自 ${remoteUserId}`);
                statusMessageSpan.textContent = `与 ${remoteUserId} 连接已建立`;
                isConnectedToVoice = true; // At least one voice connection is active
                updateUI();
            } catch (error) {
                console.error(`处理来自 ${remoteUserId} 的应答失败:`, error);
                statusMessageSpan.textContent = `处理应答失败: ${error.message}`;
                showCustomModal("处理应答失败", `处理来自 ${remoteUserId} 的 WebRTC 应答时发生错误: ${error.message}`);
            }
        }

        // 8. Handle incoming ICE candidate
        async function handleIceCandidate(pc, candidate, remoteUserId) {
            try {
                // Only add candidate if PC is not closed and remote description is set
                if (pc.connectionState !== 'closed' && pc.remoteDescription) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    console.log(`已添加来自 ${remoteUserId} 的ICE候选者`);
                } else {
                    console.warn(`PC for ${remoteUserId} is not ready to add ICE candidate. State: ${pc.connectionState}`);
                }
            } catch (error) {
                console.error(`添加来自 ${remoteUserId} 的ICE候选者失败:`, error);
                statusMessageSpan.textContent = `添加ICE候选者失败: ${error.message}`;
            }
        }

        // 9. Leave Room
        async function leaveRoom() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                if (localAudioRef) {
                    localAudioRef.srcObject = null;
                }
            }

            // Close all peer connections and remove their audio elements
            peerConnections.forEach((pc, remoteId) => {
                pc.close();
                const audioEl = document.getElementById(`remoteAudio-${remoteId}`);
                if (audioEl) audioEl.remove();
            });
            peerConnections.clear(); // Clear the map
            if (remoteAudiosContainer) {
                remoteAudiosContainer.classList.add('hidden'); // Hide container
            }

            // Clear all signal listeners
            unsubscribeSignals.forEach(unsub => unsub());
            unsubscribeSignals = [];
            if (unsubscribeMessages) {
                unsubscribeMessages();
                unsubscribeMessages = null;
            }
            if (unsubscribeRoomUsers) {
                unsubscribeRoomUsers();
                unsubscribeRoomUsers = null;
            }

            // Clean up signaling data in Firestore for this user
            if (db && userId && currentRoomId) {
                try {
                    // Delete our own presence marker (offer document)
                    await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`, userId));
                    console.log('已清除Firestore信令数据 (存在标记)');

                    // Clean up our sent signals (offers, answers, candidates)
                    const batch = writeBatch(db); // Use batch writes for efficiency
                    const sentSignalsPath = `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/signals/${userId}`;
                    const sentOffersSnapshot = await getDocs(collection(db, `${sentSignalsPath}/offers`));
                    sentOffersSnapshot.forEach(doc => batch.delete(doc.ref));
                    const sentAnswersSnapshot = await getDocs(collection(db, `${sentSignalsPath}/answers`));
                    sentAnswersSnapshot.forEach(doc => batch.delete(doc.ref));
                    const sentCandidatesSnapshot = await getDocs(collection(db, `${sentSignalsPath}/candidates`));
                    sentCandidatesSnapshot.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    console.log('已清除 Firestore 中我们发送的信令数据。');

                    // Optional: If the room becomes completely empty, delete the room document itself
                    // This is more complex for subcollections, but the main 'offers' collection can indicate active users.
                    const roomOffers = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/offers`));
                    if (roomOffers.empty) {
                        const roomMessages = await getDocs(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/messages`));
                        if (roomMessages.empty) {
                            // Only delete the top-level room document if all subcollections are empty (offers, messages, and signals)
                            // This part is simplified and might not catch all nested subcollections.
                            // For full cleanup, a Cloud Function triggered by last user leaving is recommended.
                            await deleteDoc(doc(db, `artifacts/${appId}/public/data/voice_chat_rooms`, currentRoomId));
                            console.log('房间已空，已删除房间文档');
                        }
                    }

                } catch (error) {
                    console.error('清除Firestore数据失败:', error);
                    statusMessageSpan.textContent = '清除Firestore数据失败: ' + error.message;
                }
            }

            currentRoomId = '';
            statusMessageSpan.textContent = '已离开房间';
            messagesContainer.innerHTML = '<p class="text-gray-500 text-center italic">还没有消息... (拖放图片到这里发送)</p>'; // Clear messages
            isLocalMicMuted = false;
            isRemoteAudioMuted = false;
            isConnectedToVoice = false;
            roomUserCount = 0; // Reset user count on leaving
            updateUI();
            console.log('已离开房间');
        }

        // 10. Send text or image message
        async function sendMessage(messageText = '', imageData = '') {
            if (!db || !userId || !currentRoomId || (messageText.trim() === '' && imageData === '')) {
                statusMessageSpan.textContent = '无法发送消息：请加入房间并输入内容或拖入图片';
                return;
            }

            isSendingImage = true;
            updateUI(); // Update UI to show loading state
            try {
                await addDoc(collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${currentRoomId}/messages`), {
                    senderId: userId,
                    text: messageText,
                    imageData: imageData,
                    timestamp: Date.now(),
                });
                newMessageInput.value = '';
                statusMessageSpan.textContent = '消息已发送';
            } catch (error) {
                console.error('发送消息失败:', error);
                statusMessageSpan.textContent = '发送消息失败: ' + error.message;
                showCustomModal("发送消息失败", `发送消息时发生错误: ${error.message}`);
            } finally {
                isSendingImage = false;
                updateUI(); // Update UI to clear loading state
            }
        }

        // 11. Listen for text messages
        let unsubscribeMessages = null; // To store the unsubscribe function
        function listenForTextMessages(roomId) {
            if (unsubscribeMessages) {
                unsubscribeMessages(); // Unsubscribe from previous room's messages
            }
            if (!db || !roomId) return;

            const messagesRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/messages`);
            const q = query(messagesRef);

            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                const newMessages = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                newMessages.sort((a, b) => a.timestamp - b.timestamp);

                messagesContainer.innerHTML = ''; // Clear existing messages
                if (newMessages.length === 0) {
                    messagesContainer.innerHTML = '<p class="text-gray-500 text-center italic">还没有消息... (拖放图片到这里发送)</p>';
                } else {
                    newMessages.forEach(msg => {
                        const messageDiv = document.createElement('div');
                        messageDiv.className = `mb-2 ${msg.senderId === userId ? 'text-right' : 'text-left'}`;
                        const contentSpan = document.createElement('span');
                        contentSpan.className = `inline-block p-2 rounded-lg max-w-[80%] ${msg.senderId === userId ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'}`;

                        const senderStrong = document.createElement('strong');
                        senderStrong.className = 'text-xs';
                        senderStrong.textContent = msg.senderId === userId ? '您' : `用户 ${msg.senderId}`;
                        contentSpan.appendChild(senderStrong);

                        if (msg.imageData) {
                            const img = document.createElement('img');
                            img.src = msg.imageData;
                            img.alt = '聊天图片';
                            img.className = 'max-w-full h-auto rounded-md mt-1';
                            img.onerror = (e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/150x100/FF0000/FFFFFF?text=图片加载失败'; };
                            contentSpan.appendChild(img);
                        } else {
                            const p = document.createElement('p');
                            p.textContent = msg.text;
                            contentSpan.appendChild(p);
                        }

                        const timestampSpan = document.createElement('span');
                        timestampSpan.className = 'block text-xs text-opacity-75 mt-1';
                        timestampSpan.textContent = new Date(msg.timestamp).toLocaleTimeString();
                        contentSpan.appendChild(timestampSpan);

                        messageDiv.appendChild(contentSpan);
                        messagesContainer.appendChild(messageDiv);
                    });
                }

                messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll to bottom
            }, (error) => {
                console.error("监听消息失败:", error);
                statusMessageSpan.textContent = "监听消息失败: " + error.message;
                showCustomModal("加载消息失败", `无法加载聊天消息: ${error.message}`);
            });
        }

        // Listen for room users (presence based on 'offers' collection)
        let unsubscribeRoomUsers = null;
        function listenForRoomUsers(roomId) {
            if (unsubscribeRoomUsers) {
                unsubscribeRoomUsers(); // Unsubscribe from previous room's user listener
            }
            if (!db || !roomId) return;

            // We use the 'offers' collection as a simple presence indicator
            const offersRef = collection(db, `artifacts/${appId}/public/data/voice_chat_rooms/${roomId}/offers`);
            unsubscribeRoomUsers = onSnapshot(offersRef, (snapshot) => {
                roomUserCount = snapshot.size; // Get the number of documents (users who published an offer/presence)
                updateUI();
            }, (error) => {
                console.error("监听房间人数失败:", error);
                statusMessageSpan.textContent = "监听房间人数失败: " + error.message;
            });
        }


        // Handle drag over event for image drop
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        }

        // Handle drop event for image
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!currentRoomId) {
                statusMessageSpan.textContent = '请先加入房间才能发送图片';
                showCustomModal("发送图片失败", "请先加入一个房间才能发送图片。");
                return;
            }

            isSendingImage = true;
            updateUI(); // Show loading indicator

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        sendMessage('', event.target.result); // Send image data
                    };
                    reader.onerror = (error) => {
                        console.error('读取图片失败:', error);
                        statusMessageSpan.textContent = '读取图片失败: ' + error.message;
                        showCustomModal("读取图片失败", `无法读取图片文件: ${error.message}`);
                        isSendingImage = false;
                        updateUI();
                    };
                    reader.readAsDataURL(file);
                } else {
                    statusMessageSpan.textContent = '只能拖入图片文件';
                    showCustomModal("无效文件类型", "您只能拖入图片文件。");
                    isSendingImage = false;
                    updateUI();
                }
            } else {
                isSendingImage = false;
                updateUI();
            }
        }

        // Toggle local microphone mute
        function toggleLocalMic() {
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled;
                });
                isLocalMicMuted = !isLocalMicMuted;
                statusMessageSpan.textContent = isLocalMicMuted ? '麦克风已开启' : '麦克风已静音';
                updateUI();
            } else {
                statusMessageSpan.textContent = '请先加入房间以控制麦克风';
                showCustomModal("操作失败", "请先加入房间以控制麦克风。");
            }
        }

        // Toggle remote audio mute (now mutes/unmutes all remote streams)
        function toggleRemoteAudio() {
            if (remoteAudiosContainer.children.length > 0) {
                isRemoteAudioMuted = !isRemoteAudioMuted;
                Array.from(remoteAudiosContainer.children).forEach(audioEl => {
                    audioEl.muted = isRemoteAudioMuted;
                });
                statusMessageSpan.textContent = isRemoteAudioMuted ? '所有对方已静音' : '所有对方已取消静音';
                updateUI();
            } else {
                statusMessageSpan.textContent = '没有远程音频流可静音';
                showCustomModal("操作失败", "没有远程音频流可静音。请确保已连接到语音聊天。");
            }
        }

        // Function to copy User ID to clipboard
        function copyUserIdToClipboard() {
            if (userId) {
                const tempInput = document.createElement('textarea');
                tempInput.value = userId;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                statusMessageSpan.textContent = '用户ID已复制到剪贴板！';
            }
        }

        // Event Listeners
        window.onload = () => {
            initializeFirebase();
            updateUI(); // Initial UI update

            joinRoomBtn.addEventListener('click', joinRoom);
            leaveRoomBtn.addEventListener('click', leaveRoom);
            toggleLocalMicBtn.addEventListener('click', toggleLocalMic);
            toggleRemoteAudioBtn.addEventListener('click', toggleRemoteAudio);
            sendMessageBtn.addEventListener('click', () => sendMessage(newMessageInput.value));
            newMessageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage(newMessageInput.value);
                }
            });
            roomIdInput.addEventListener('input', updateUI); // Update UI when room ID changes
            copyUserIdBtn.addEventListener('click', copyUserIdToClipboard);
            modalCloseBtn.addEventListener('click', () => customModal.classList.add('hidden'));

            // Drag and drop listeners for messages container
            messagesContainer.addEventListener('dragover', handleDragOver);
            messagesContainer.addEventListener('drop', handleDrop);
        };
    </script>
</body>
</html>
